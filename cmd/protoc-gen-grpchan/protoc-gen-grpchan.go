// Command protoc-gen-grpchan is a protoc plugin that generates gRPC client stubs
// in Go that use github.com/fullstorydev/grpchan.Channel as their transport
// abstraction, instead of using *grpc.ClientConn. This can be used to carry RPC
// requests and streams over other transports, such as HTTP 1.1 or in-process.
package main

import (
	"fmt"
	"path"
	"strings"
	"text/template"

	"github.com/jhump/gopoet"
	"github.com/jhump/goprotoc/plugins"
	"github.com/jhump/protoreflect/desc"
)

func main() {
	plugins.PluginMain(doCodeGen)
}

func doCodeGen(req *plugins.CodeGenRequest, resp *plugins.CodeGenResponse) error {
	args, err := parseArgs(req.Args)
	if err != nil {
		return err
	}
	names := plugins.GoNames{ImportMap: args.importMap}
	if args.importPath != "" {
		// if we're overriding import path, go ahead and query
		// package for each file, which will cache the override name
		// so all subsequent queries are consistent
		for _, fd := range req.Files {
			names.GoPackageForFileWithOverride(fd, args.importPath)
		}
	}
	for _, fd := range req.Files {
		if err := generateChanStubs(fd, &names, resp); err != nil {
			if fe, ok := err.(*gopoet.FormatError); ok {
				if args.debug {
					return fmt.Errorf("%s: error in generated Go code: %v:\n%s", fd.GetName(), err, fe.Unformatted)
				} else {
					return fmt.Errorf("%s: error in generated Go code: %v (use debug=true arg to show full source)", fd.GetName(), err)
				}
			} else {
				return fmt.Errorf("%s: %v", fd.GetName(), err)
			}
		}
	}
	return nil
}

var typeOfRegistry = gopoet.NamedType(gopoet.NewSymbol("github.com/fullstorydev/grpchan", "ServiceRegistry"))
var typeOfChannel = gopoet.NamedType(gopoet.NewSymbol("github.com/fullstorydev/grpchan", "Channel"))
var typeOfContext = gopoet.NamedType(gopoet.NewSymbol("golang.org/x/net/context", "Context"))
var typeOfCallOptions = gopoet.SliceType(gopoet.NamedType(gopoet.NewSymbol("google.golang.org/grpc", "CallOption")))

func generateChanStubs(fd *desc.FileDescriptor, names *plugins.GoNames, resp *plugins.CodeGenResponse) error {
	if len(fd.GetServices()) == 0 {
		return nil
	}

	pkg := names.GoPackageForFile(fd)
	filename := names.OutputFilenameFor(fd, ".pb.grpchan.go")
	f := gopoet.NewGoFile(path.Base(filename), pkg.ImportPath, pkg.Name)

	f.FileComment = "Code generated by protoc-gen-grpchan. DO NOT EDIT.\n" +
		"source: " + fd.GetName()

	for _, sd := range fd.GetServices() {
		svcName := names.CamelCase(sd.GetName())
		lowerSvcName := gopoet.Unexport(svcName)

		f.AddElement(gopoet.NewFunc(fmt.Sprintf("RegisterHandler%s", svcName)).
			AddArg("reg", typeOfRegistry).
			AddArg("srv", names.GoTypeForServiceServer(sd)).
			Printlnf("reg.RegisterService(&%s, srv)", names.GoNameOfServiceDesc(sd)))

		cc := gopoet.NewStructTypeSpec(fmt.Sprintf("%sChannelClient", lowerSvcName),
			gopoet.NewField("ch", typeOfChannel))
		f.AddType(cc)

		f.AddElement(gopoet.NewFunc(fmt.Sprintf("New%sChannelClient", svcName)).
			AddArg("ch", typeOfChannel).
			AddResult("", names.GoTypeForServiceClient(sd)).
			Printlnf("return &%s{ch: ch}", cc))

		streamCount := 0
		tmpls := templates{}
		for _, md := range sd.GetMethods() {
			methodInfo := struct {
				ServiceName  string
				MethodName   string
				ServiceDesc  string
				StreamClient string
				StreamIndex  int
				RequestType  gopoet.TypeName
			}{
				ServiceName:  sd.GetFullyQualifiedName(),
				MethodName:   md.GetName(),
				ServiceDesc:  names.GoNameOfServiceDesc(sd),
				StreamClient: names.GoTypeForStreamClientImpl(md),
				StreamIndex:  streamCount,
				RequestType:  names.GoTypeForMessage(md.GetOutputType()),
			}
			mtdName := names.CamelCase(md.GetName())
			if md.IsClientStreaming() {
				// bidi or client streaming method
				f.AddElement(gopoet.NewMethod(gopoet.NewPointerReceiverForType("c", cc), mtdName).
					AddArg("ctx", typeOfContext).
					AddArg("opts", typeOfCallOptions).
					SetVariadic(true).
					AddResult("", names.GoTypeForStreamClient(md)).
					AddResult("", gopoet.ErrorType).
					RenderCode(tmpls.makeTemplate(
						`stream, err := c.ch.NewStream(ctx, &{{.ServiceDesc}}.Streams[{{.StreamIndex}}], "/{{.ServiceName}}/{{.MethodName}}", opts...)
						if err != nil {
							return nil, err
						}
						x := &{{.StreamClient}}{stream}
						return x, nil`), &methodInfo))
				streamCount++
			} else if md.IsServerStreaming() {
				// server streaming method
				f.AddElement(gopoet.NewMethod(gopoet.NewPointerReceiverForType("c", cc), mtdName).
					AddArg("ctx", typeOfContext).
					AddArg("in", names.GoTypeOfRequest(md)).
					AddArg("opts", typeOfCallOptions).
					SetVariadic(true).
					AddResult("", names.GoTypeForStreamClient(md)).
					AddResult("", gopoet.ErrorType).
					RenderCode(tmpls.makeTemplate(
						`stream, err := c.ch.NewStream(ctx, &{{.ServiceDesc}}.Streams[{{.StreamIndex}}], "/{{.ServiceName}}/{{.MethodName}}", opts...)
						if err != nil {
							return nil, err
						}
						x := &{{.StreamClient}}{stream}
						if err := x.ClientStream.SendMsg(in); err != nil {
						    return nil, err
						}
						if err := x.ClientStream.CloseSend(); err != nil {
						    return nil, err
						}
						return x, nil`), &methodInfo))
				streamCount++
			} else {
				// unary method
				f.AddElement(gopoet.NewMethod(gopoet.NewPointerReceiverForType("c", cc), mtdName).
					AddArg("ctx", typeOfContext).
					AddArg("in", names.GoTypeOfRequest(md)).
					AddArg("opts", typeOfCallOptions).
					SetVariadic(true).
					AddResult("", names.GoTypeOfResponse(md)).
					AddResult("", gopoet.ErrorType).
					RenderCode(tmpls.makeTemplate(
						`out := new({{.RequestType}})
						err := c.ch.Invoke(ctx, "/{{.ServiceName}}/{{.MethodName}}", in, out, opts...)
						if err != nil {
							return nil, err
						}
						return out, nil`), &methodInfo))
			}
		}
	}

	out := resp.OutputFile(filename)
	return gopoet.WriteGoFile(out, f)
}

type templates map[string]*template.Template

func (t templates) makeTemplate(templateText string) *template.Template {
	tpl := t[templateText]
	if tpl == nil {
		tpl = template.Must(template.New("code").Parse(templateText))
		t[templateText] = tpl
	}
	return tpl
}

type codeGenArgs struct {
	debug      bool
	importPath string
	importMap  map[string]string
}

func parseArgs(args []string) (codeGenArgs, error) {
	var result codeGenArgs
	for _, arg := range args {
		vals := strings.SplitN(arg, "=", 2)
		switch vals[0] {
		case "debug":
			if len(vals) == 1 {
				// if no value, assume "true"
				result.debug = true
				break
			}
			switch strings.ToLower(vals[1]) {
			case "true", "on", "yes", "1":
				result.debug = true
			case "false", "off", "no", "0":
				result.debug = false
			default:
				return result, fmt.Errorf("invalid boolean arg for option 'debug': %s", vals[1])
			}

		case "import_path":
			if len(vals) == 1 {
				return result, fmt.Errorf("plugin option 'import_path' requires an argument")
			}
			result.importPath = vals[1]

		default:
			if len(vals[0]) > 1 && vals[0][0] == 'M' {
				if len(vals) == 1 {
					return result, fmt.Errorf("plugin 'M' options require an argument: %s", vals[0])
				}
				if result.importMap == nil {
					result.importMap = map[string]string{}
				}
				result.importMap[vals[0][1:]] = vals[1]
				break
			}

			return result, fmt.Errorf("unknown plugin option: %s", vals[0])
		}
	}
	return result, nil
}
