// Command protoc-gen-grpchan is a protoc plugin that generates gRPC client stubs
// in Go that use github.com/fullstorydev/grpchan.Channel as their transport
// abstraction, instead of using *grpc.ClientConn. This can be used to carry RPC
// requests and streams over other transports, such as HTTP 1.1 or in-process.
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/jhump/protoreflect/desc"
)

func main() {
	fail := func(err error, message string) {
		if err == nil {
			fmt.Fprintln(os.Stderr, message)
		} else {
			fmt.Fprintf(os.Stderr, "%s: %v\n", message, err)
		}
		os.Exit(1)
	}

	data, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		fail(err, "reading input")
	}

	var cgReq plugin_go.CodeGeneratorRequest
	if err := proto.Unmarshal(data, &cgReq); err != nil {
		fail(err, "parsing input proto")
	}

	if len(cgReq.FileToGenerate) == 0 {
		fail(nil, "no files to generate")
	}

	files := map[string]*desc.FileDescriptor{}
	var deps []*desc.FileDescriptor
	for _, fdp := range cgReq.ProtoFile {
		fd, err := desc.CreateFileDescriptor(fdp, deps...)
		if err != nil {
			fail(err, "parsing input descriptors")
		}
		files[fd.GetName()] = fd
		deps = append(deps, fd)
	}

	var cgResp plugin_go.CodeGeneratorResponse
	for _, name := range cgReq.FileToGenerate {
		if respFile, err := generateChanStubs(files[name]); err != nil {
			cgResp.File = nil
			cgResp.Error = proto.String(fmt.Sprintf("%s: %s", name, err.Error()))
			break
		} else if respFile != nil {
			cgResp.File = append(cgResp.File, respFile)
		}
	}

	// Send back the results.
	data, err = proto.Marshal(&cgResp)
	if err != nil {
		fail(err, "failed to marshal output proto")
	}
	_, err = os.Stdout.Write(data)
	if err != nil {
		fail(err, "failed to write output proto")
	}
}

func generateChanStubs(fd *desc.FileDescriptor) (*plugin_go.CodeGeneratorResponse_File, error) {
	if fd == nil {
		panic("file descriptor is nil!")
	}
	if len(fd.GetServices()) == 0 {
		return nil, nil
	}

	var file plugin_go.CodeGeneratorResponse_File

	filename, pkg := determineFileAndPkg(fd)
	file.Name = proto.String(filename)

	var buf bytes.Buffer
	w := func(format string, args ...interface{}) {
		fmt.Fprintf(&buf, format+"\n", args...)
	}

	imports := gatherImports(fd)

	w("// Code generated by protoc-gen-grpchan. DO NOT EDIT.")
	w("// source: %s", fd.GetName())
	w("")
	w("package %s", pkg)
	w("")
	w("import (")
	for _, imp := range imports.imports {
		if imp.alias != "" {
			w("	%s %q", imp.alias, imp.packagePath)
		} else {
			w("	%q", imp.packagePath)
		}
	}
	w(")")

	for _, sd := range fd.GetServices() {
		svcName := export(sd.GetName())
		lowerSvcName := unexport(svcName)

		w("")
		w("func RegisterHandler%s(reg grpchan.ServiceRegistry, srv %sServer) {", svcName, svcName)
		w("	reg.RegisterService(&_%s_serviceDesc, srv)", svcName)
		w("}")
		w("")
		w("type %sChannelClient struct {", lowerSvcName)
		w("	ch grpchan.Channel")
		w("}")
		w("")
		w("func New%sChannelClient(ch grpchan.Channel) %sClient {", svcName, svcName)
		w("	return &%sChannelClient{ch: ch}", lowerSvcName)
		w("}")

		streamCount := 0
		for _, md := range sd.GetMethods() {
			mtdName := export(md.GetName())
			w("")
			if md.IsClientStreaming() {
				// bidi or client streaming method
				w("func (c *%sChannelClient) %s(ctx context.Context, opts ...grpc.CallOption) (%s_%sClient, error) {", lowerSvcName, mtdName, svcName, mtdName)
				w("	stream, err := c.ch.NewStream(ctx, &_%s_serviceDesc.Streams[%d], \"/%s/%s\", opts...)", svcName, streamCount, sd.GetFullyQualifiedName(), md.GetName())
				w("	if err != nil {")
				w("		return nil, err")
				w("	}")
				w("	x := &%s%sClient{stream}", lowerSvcName, md.GetName())
				w("	return x, nil")
				w("}")
				streamCount++
			} else if md.IsServerStreaming() {
				// server streaming method
				w("func (c *%sChannelClient) %s(ctx context.Context, in *%s%s, opts ...grpc.CallOption) (%s_%sClient, error) {", lowerSvcName, mtdName, imports.prefixesByFile[md.GetInputType().GetFile()], export(md.GetInputType().GetName()), svcName, mtdName)
				w("	stream, err := c.ch.NewStream(ctx, &_%s_serviceDesc.Streams[%d], \"/%s/%s\", opts...)", svcName, streamCount, sd.GetFullyQualifiedName(), md.GetName())
				w("	if err != nil {")
				w("		return nil, err")
				w("	}")
				w("	x := &%s%sClient{stream}", lowerSvcName, md.GetName())
				w("	if err := x.ClientStream.SendMsg(in); err != nil {")
				w("		return nil, err")
				w("	}")
				w("	if err := x.ClientStream.CloseSend(); err != nil {")
				w("		return nil, err")
				w("	}")
				w("	return x, nil")
				w("}")
				streamCount++
			} else {
				// unary method
				w("func (c *%sChannelClient) %s(ctx context.Context, in *%s%s, opts ...grpc.CallOption) (*%s%s, error) {", lowerSvcName, mtdName, imports.prefixesByFile[md.GetInputType().GetFile()], export(md.GetInputType().GetName()), imports.prefixesByFile[md.GetOutputType().GetFile()], export(md.GetOutputType().GetName()))
				w("	out := new(%s%s)", imports.prefixesByFile[md.GetOutputType().GetFile()], export(md.GetOutputType().GetName()))
				w("	err := c.ch.Invoke(ctx, \"/%s/%s\", in, out, opts...)", sd.GetFullyQualifiedName(), md.GetName())
				w("	if err != nil {")
				w("		return nil, err")
				w("	}")
				w("	return out, nil")
				w("}")
			}
		}
	}

	file.Content = proto.String(buf.String())

	return &file, nil
}

func determineFileAndPkg(fd *desc.FileDescriptor) (outputFile, pkg string) {
	fileName, protoPackage, goOption := fd.GetName(), fd.GetPackage(), fd.GetFileOptions().GetGoPackage()
	var pkgPath, pkgAlias string
	if goOption == "" {
		pkgPath = path.Dir(fileName)
		if protoPackage == "" {
			n := path.Base(fileName)
			ext := path.Ext(n)
			if ext == "" || len(ext) == len(n) {
				pkgAlias = n
			} else {
				pkgAlias = n[:len(n)-len(ext)]
			}
		} else {
			pkgAlias = protoPackage
		}
		pkgAlias = strings.Replace(pkgAlias, ".", "_", -1)
	} else {
		parts := strings.Split(goOption, ";")
		if len(parts) > 1 {
			pkgPath = parts[0]
			pkgAlias = parts[1]
		} else {
			pkgAlias = path.Base(parts[0])
			if strings.Contains(parts[0], "/") {
				pkgPath = parts[0]
			} else {
				pkgPath = path.Dir(fileName)
			}
		}
	}

	fname := strings.Replace(path.Base(fileName), ".proto", ".pb.grpchan.go", -1)
	return path.Join(pkgPath, fname), pkgAlias
}

func gatherImports(fd *desc.FileDescriptor) importSpecs {
	imports := importSpecs{
		prefixesByFile: map[*desc.FileDescriptor]string{},
	}

	packagesByAlias := map[string]string{}
	isAlias := map[string]struct{}{}
	imports.prefixesByFile[fd] = ""
	packagesByAlias["grpc"] = "google.golang.org/grpc"
	packagesByAlias["context"] = "golang.org/x/net/context"
	packagesByAlias["grpchan"] = "github.com/fullstorydev/grpchan"

	thisFn, thisPkg := determineFileAndPkg(fd)
	thisPkgPath := path.Dir(thisFn)

	for _, sd := range fd.GetServices() {
		for _, md := range sd.GetMethods() {
			var msgTypes []*desc.MessageDescriptor
			// We need to import messages referenced in method signatures.
			// Client- and bidi-streaming messages only refer to a stream type
			// (defined elsewhere, messages types referenced therein). But
			// server-streaming methods reference the request type in their
			// signature. And unary methods reference both request and response
			// types.
			if !md.IsClientStreaming() {
				msgTypes = append(msgTypes, md.GetInputType())
				if !md.IsServerStreaming() {
					msgTypes = append(msgTypes, md.GetOutputType())
				}
			}

			for _, msgd := range msgTypes {
				if _, ok := imports.prefixesByFile[msgd.GetFile()]; ok {
					continue // already set this one
				}
				fn, pkg := determineFileAndPkg(msgd.GetFile())
				pkgPath := path.Dir(fn)
				if pkgPath == thisPkgPath && pkg == thisPkg {
					// same package, different proto file; give the proto file an empty alias/prefix
					imports.prefixesByFile[msgd.GetFile()] = ""
					continue
				}
				alias := pkg
				i := 0
				for {
					if prevPkg, ok := packagesByAlias[alias]; !ok || prevPkg == pkgPath {
						break
					}
					i++
					alias = fmt.Sprintf("%s%d", pkg, i)
				}
				imports.prefixesByFile[msgd.GetFile()] = alias + "."
				packagesByAlias[alias] = pkgPath
				if alias != pkg {
					isAlias[alias] = struct{}{}
				}
			}
		}
	}

	for alias, pkg := range packagesByAlias {
		spec := importSpec{packagePath: pkg}
		if _, ok := isAlias[alias]; ok {
			spec.alias = alias
		}
		imports.imports = append(imports.imports, spec)
	}

	// sort by package path
	sort.Slice(imports.imports, func(i, j int) bool {
		return imports.imports[i].packagePath < imports.imports[j].packagePath
	})

	return imports
}

type importSpecs struct {
	prefixesByFile map[*desc.FileDescriptor]string
	imports        []importSpec
}

type importSpec struct {
	alias, packagePath string
}

func export(s string) string {
	return changeFirst(s, func(r rune) rune { return unicode.ToUpper(r) })
}

func unexport(s string) string {
	return changeFirst(s, func(r rune) rune { return unicode.ToLower(r) })
}

func changeFirst(s string, fn func(rune) rune) string {
	r, sz := utf8.DecodeRuneInString(s)
	r = fn(r)
	return string(r) + s[sz:]
}
